<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bangladeshi Monopoly</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for the game board and elements */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        .board {
            display: grid;
            grid-template-columns: 1.6fr repeat(9, 1fr) 1.6fr; /* 11 columns */
            grid-template-rows: 1.6fr repeat(9, 1fr) 1.6fr;    /* 11 rows */
            width: 90vmin; /* Responsive board size */
            height: 90vmin;
            max-width: 800px;
            max-height: 800px;
            margin: 2rem auto;
            border: 2px solid black;
            background-color: #cde6d0; /* Traditional Monopoly green */
            position: relative; /* For positioning players */
        }

        .space {
            border: 1px solid black;
            position: relative; /* For ownership markers */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Distribute content vertically */
            align-items: center;
            text-align: center;
            font-size: clamp(0.6rem, 1.2vmin, 0.8rem); /* Responsive font size */
            overflow: hidden;
            padding: 3px; /* Slightly more padding */
            line-height: 1.1; /* Adjust line height */
        }

        /* Ensure corners span correctly */
        .corner { grid-row: span 1; grid-column: span 1; }
        /* Row/Column assignments remain the same logically, but sizes are now relative */
        .top-row { grid-row: 1; }
        .bottom-row { grid-row: 11; }
        .left-col { grid-column: 1; }
        .right-col { grid-column: 11; }

        /* Assigning spaces to grid cells (No change needed here) */
        #space-0 { grid-area: 11 / 11; } /* Go */
        #space-1 { grid-area: 11 / 10; }
        #space-2 { grid-area: 11 / 9; }
        #space-3 { grid-area: 11 / 8; }
        #space-4 { grid-area: 11 / 7; }
        #space-5 { grid-area: 11 / 6; }
        #space-6 { grid-area: 11 / 5; }
        #space-7 { grid-area: 11 / 4; }
        #space-8 { grid-area: 11 / 3; }
        #space-9 { grid-area: 11 / 2; }
        #space-10 { grid-area: 11 / 1; } /* Jail */
        #space-11 { grid-area: 10 / 1; }
        #space-12 { grid-area: 9 / 1; }
        #space-13 { grid-area: 8 / 1; }
        #space-14 { grid-area: 7 / 1; }
        #space-15 { grid-area: 6 / 1; }
        #space-16 { grid-area: 5 / 1; }
        #space-17 { grid-area: 4 / 1; }
        #space-18 { grid-area: 3 / 1; }
        #space-19 { grid-area: 2 / 1; }
        #space-20 { grid-area: 1 / 1; } /* Free Parking */
        #space-21 { grid-area: 1 / 2; }
        #space-22 { grid-area: 1 / 3; }
        #space-23 { grid-area: 1 / 4; }
        #space-24 { grid-area: 1 / 5; }
        #space-25 { grid-area: 1 / 6; }
        #space-26 { grid-area: 1 / 7; }
        #space-27 { grid-area: 1 / 8; }
        #space-28 { grid-area: 1 / 9; }
        #space-29 { grid-area: 1 / 10; }
        #space-30 { grid-area: 1 / 11; } /* Go to Jail */
        #space-31 { grid-area: 2 / 11; }
        #space-32 { grid-area: 3 / 11; }
        #space-33 { grid-area: 4 / 11; }
        #space-34 { grid-area: 5 / 11; }
        #space-35 { grid-area: 6 / 11; }
        #space-36 { grid-area: 7 / 11; }
        #space-37 { grid-area: 8 / 11; }
        #space-38 { grid-area: 9 / 11; }
        #space-39 { grid-area: 10 / 11; }

        .center-area {
            grid-area: 2 / 2 / 11 / 11; /* Center grid area */
            background-color: #a4d1a8;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            border: 1px solid black;
        }

        .property-color {
            height: 15%; /* Adjusted height */
            width: 100%;
            border-bottom: 1px solid black;
            font-size: 0.6rem;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        .space-name {
            font-weight: bold;
            padding: 2px 0;
            flex-grow: 1; /* Allow name to take available space */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column; /* Stack icon/text vertically if needed */
            width: 100%; /* Ensure it takes full width */
        }
        .space-price {
            font-size: 0.7rem; /* Slightly larger price */
            flex-shrink: 0; /* Prevent shrinking */
            margin-top: auto; /* Push price to the bottom */
        }

        /* Player Markers */
        .player-marker {
            position: absolute;
            width: 20px; /* Increased size */
            height: 20px; /* Increased size */
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.7);
            transition: top 0.5s ease-in-out, left 0.5s ease-in-out;
            z-index: 10;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px black;
            font-size: 14px; /* Ensure token is visible */
        }

        /* Dice Styling */
        .dice-container {
            display: flex;
            gap: 10px;
        }
        .dice {
            width: 50px;
            height: 50px;
            background-color: white;
            border: 1px solid black;
            border-radius: 5px;
            display: grid;
            padding: 5px;
            grid-template-areas:
                "a . c"
                "e g f"
                "d . b";
            box-shadow: inset 0 5px white, inset 0 -5px #bbb, inset 5px 0 #d7d7d7, inset -5px 0 #d7d7d7;
        }
        .dot {
            display: block;
            align-self: center;
            justify-self: center;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: black;
        }
        /* Positions for dots */
        .dot:nth-child(1) { grid-area: a; }
        .dot:nth-child(2) { grid-area: b; }
        .dot:nth-child(3) { grid-area: c; }
        .dot:nth-child(4) { grid-area: d; }
        .dot:nth-child(5) { grid-area: e; }
        .dot:nth-child(6) { grid-area: f; }
        .dot:nth-child(7) { grid-area: g; } /* Center dot */

        /* Hide dots initially */
        .dice .dot { visibility: hidden; }
        /* Show dots based on dice value class */
        .dice[data-value="1"] .dot:nth-child(7) { visibility: visible; } /* Center dot */
        .dice[data-value="2"] .dot:nth-child(1), .dice[data-value="2"] .dot:nth-child(2) { visibility: visible; }
        .dice[data-value="3"] .dot:nth-child(1), .dice[data-value="3"] .dot:nth-child(2), .dice[data-value="3"] .dot:nth-child(7) { visibility: visible; }
        .dice[data-value="4"] .dot:nth-child(1), .dice[data-value="4"] .dot:nth-child(2), .dice[data-value="4"] .dot:nth-child(3), .dice[data-value="4"] .dot:nth-child(4) { visibility: visible; }
        .dice[data-value="5"] .dot:nth-child(1), .dice[data-value="5"] .dot:nth-child(2), .dice[data-value="5"] .dot:nth-child(3), .dice[data-value="5"] .dot:nth-child(4), .dice[data-value="5"] .dot:nth-child(7) { visibility: visible; }
        .dice[data-value="6"] .dot:nth-child(1), .dice[data-value="6"] .dot:nth-child(2), .dice[data-value="6"] .dot:nth-child(3), .dice[data-value="6"] .dot:nth-child(4), .dice[data-value="6"] .dot:nth-child(5), .dice[data-value="6"] .dot:nth-child(6) { visibility: visible; }


        /* Log Screen */
        #log-screen {
            height: 150px; /* Increased height */
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 10px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        #log-screen p {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        /* Notification Modal */
        #notification-modal {
            /* Tailwind classes for modal styling */
        }
        #notification-modal-content {
            min-width: 300px; /* Ensure minimum width */
            padding: 2rem; /* More padding */
        }
        #notification-message {
            font-size: 1.1rem; /* Larger text */
            margin-bottom: 1.5rem;
        }
        #notification-buttons button {
            padding: 0.8rem 1.5rem; /* Bigger buttons */
            font-size: 1rem; /* Bigger button text */
            margin: 0 0.5rem;
        }

        /* Property Ownership Indicator */
        .ownership-marker {
            position: absolute;
            top: 1px;
            left: 1px;
            width: 15px;
            height: 15px;
            border-radius: 3px;
            border: 1px solid white;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            z-index: 1; /* Ensure it's above background but below text maybe */
        }

        /* Player Info Panel */
        .player-info {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            transition: background-color 0.3s ease;
        }
        .player-info.active-player {
            background-color: #e0f2fe; /* Light blue highlight for active player */
            border-color: #3b82f6;
        }
        .player-properties span {
            display: inline-block;
            padding: 2px 5px;
            margin: 2px;
            border-radius: 4px;
            font-size: 0.8rem;
            border: 1px solid #ccc;
        }
        .player-name-input {
            border: 1px solid #ccc;
            padding: 2px 5px;
            border-radius: 4px;
            width: 100px;
        }

        /* Style for disabled buttons */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

    </style>
</head>
<body class="bg-gray-100 p-4 flex flex-col md:flex-row gap-4">

    <div id="setup-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl text-center">
            <h2 class="text-2xl font-bold mb-6">Game Setup</h2>
            <div class="mb-4">
                <label class="block mb-2 font-semibold">Number of Players:</label>
                <select id="num-players" class="border rounded p-2 w-full">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                </select>
            </div>
            <div id="player-names-setup" class="mb-6">
                </div>
           <button id="start-game-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg text-lg">
                Start Game
            </button>
        </div>
    </div>

    <div class="flex-grow flex justify-center items-start">
        <div class="board" id="game-board">
            <div class="center-area">
                <h1 class="text-3xl font-bold mb-4 text-green-900">Bangladeshi Monopoly</h1>
                 <div class="dice-area mb-4">
                    <div class="dice-container">
                        <div id="dice1" class="dice" data-value="1"> <span class="dot"></span> <span class="dot"></span> <span class="dot"></span>
                           <span class="dot"></span> <span class="dot"></span> <span class="dot"></span>
                           <span class="dot"></span>
                        </div>
                        <div id="dice2" class="dice" data-value="1"> <span class="dot"></span> <span class="dot"></span> <span class="dot"></span>
                           <span class="dot"></span> <span class="dot"></span> <span class="dot"></span>
                           <span class="dot"></span>
                        </div>
                    </div>
                </div>
                 <div id="turn-indicator" class="mb-4 text-lg font-semibold">Player 1's Turn</div>
                 <div id="action-buttons" class="space-y-2">
                     <button id="roll-dice-btn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full">Roll Dice</button>
                     <button id="end-turn-btn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded w-full hidden">End Turn</button>
                     </div>
            </div>
            </div>
    </div>

    <div class="w-full md:w-1/3 lg:w-1/4 space-y-4">
        <div id="player-info-panels">
            </div>

        <div>
            <h3 class="text-lg font-semibold mb-2">Game Log</h3>
            <div id="log-screen" class="bg-white rounded-lg p-3 shadow">
                <p>Welcome to Bangladeshi Monopoly!</p>
            </div>
        </div>
    </div>

    <div id="notification-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div id="notification-modal-content" class="bg-white p-8 rounded-lg shadow-xl text-center">
            <p id="notification-message" class="text-xl mb-6">Notification Text</p>
            <div id="notification-buttons">
                </div>
        </div>
    </div>


    <script>
        // --- Game Configuration ---
        const STARTING_MONEY = 15000; // Starting money in Taka (৳)
        const GO_SALARY = 2000; // Salary for passing Go
        const JAIL_FINE = 500; // Fine to get out of jail
        const PLAYER_COLORS = ['#FF0000', '#0000FF', '#008000', '#FFFF00']; // Red, Blue, Green, Yellow
        const PLAYER_TOKENS = ['🚗', '🎩', '🚢', '👢']; // Example tokens

        // --- Board Definition (Bangladeshi Theme) ---
        const boardSpaces = [
            { name: "শুরু (Go)", type: "go" },
            { name: "পুরান ঢাকা", price: 600, rent: 20, group: "Brown", type: "property", color: "bg-yellow-800" },
            { name: "কমিউনিটি চেস্ট", type: "community-chest" },
            { name: "লালবাগ কেল্লা", price: 600, rent: 40, group: "Brown", type: "property", color: "bg-yellow-800" },
            { name: "আয়কর (Income Tax)", type: "tax", amount: 2000 },
            { name: "কমলাপুর স্টেশন", price: 2000, rent: 250, type: "station" },
            { name: "মতিঝিল", price: 1000, rent: 60, group: "LightBlue", type: "property", color: "bg-sky-300" },
            { name: "চান্স", type: "chance" },
            { name: "দিলকুশা", price: 1000, rent: 60, group: "LightBlue", type: "property", color: "bg-sky-300" },
            { name: "নয়া পল্টন", price: 1200, rent: 80, group: "LightBlue", type: "property", color: "bg-sky-300" },
            { name: "জেল (Jail)", type: "jail" },
            { name: "ফার্মগেট", price: 1400, rent: 100, group: "Pink", type: "property", color: "bg-pink-500" },
            { name: "বিদ্যুৎ সরবরাহ (Electric)", price: 1500, type: "utility" },
            { name: "এলিফ্যান্ট রোড", price: 1400, rent: 100, group: "Pink", type: "property", color: "bg-pink-500" },
            { name: "নিউ মার্কেট", price: 1600, rent: 120, group: "Pink", type: "property", color: "bg-pink-500" },
            { name: "বিমানবন্দর স্টেশন", price: 2000, rent: 250, type: "station" },
            { name: "ধানমন্ডি", price: 1800, rent: 140, group: "Orange", type: "property", color: "bg-orange-500" },
            { name: "কমিউনিটি চেস্ট", type: "community-chest" },
            { name: "মোহাম্মদপুর", price: 1800, rent: 140, group: "Orange", type: "property", color: "bg-orange-500" },
            { name: "শ্যামলী", price: 2000, rent: 160, group: "Orange", type: "property", color: "bg-orange-500" },
            { name: "ফ্রি পার্কিং", type: "free-parking" },
            { name: "গুলশান", price: 2200, rent: 180, group: "Red", type: "property", color: "bg-red-500" },
            { name: "চান্স", type: "chance" },
            { name: "বনানী", price: 2200, rent: 180, group: "Red", type: "property", color: "bg-red-500" },
            { name: "বারিধারা", price: 2400, rent: 200, group: "Red", type: "property", color: "bg-red-500" },
            { name: "চট্টগ্রাম স্টেশন", price: 2000, rent: 250, type: "station" },
            { name: "উত্তরা", price: 2600, rent: 220, group: "Yellow", type: "property", color: "bg-yellow-400" },
            { name: "মিরপুর", price: 2600, rent: 220, group: "Yellow", type: "property", color: "bg-yellow-400" },
            { name: "পানি সরবরাহ (Water Works)", price: 1500, type: "utility" },
            { name: "বসুন্ধরা", price: 2800, rent: 240, group: "Yellow", type: "property", color: "bg-yellow-400" },
            { name: "জেলে যাও (Go to Jail)", type: "go-to-jail" },
            { name: "কক্সবাজার", price: 3000, rent: 260, group: "Green", type: "property", color: "bg-green-600" },
            { name: "সেন্ট মার্টিন", price: 3000, rent: 260, group: "Green", type: "property", color: "bg-green-600" },
            { name: "কমিউনিটি চেস্ট", type: "community-chest" },
            { name: "বান্দরবান", price: 3200, rent: 280, group: "Green", type: "property", color: "bg-green-600" },
            { name: "সিলেট স্টেশন", price: 2000, rent: 250, type: "station" },
            { name: "চান্স", type: "chance" },
            { name: "শ্রীমঙ্গল", price: 3500, rent: 350, group: "DarkBlue", type: "property", color: "bg-blue-800" },
            { name: "বিলাস কর (Luxury Tax)", type: "tax", amount: 1000 },
            { name: "জাফলং", price: 4000, rent: 500, group: "DarkBlue", type: "property", color: "bg-blue-800" },
        ];

        // --- Chance Cards Definition (Example) ---
        const chanceCards = [
            { text: "Advance to Go (Collect ৳2000).", action: "move_to", spaceIndex: 0, collectGo: true },
            { text: "Advance to মতিঝিল.", action: "move_to", spaceIndex: 6 },
            { text: "Advance token to nearest Utility. If unowned, you may buy it from the Bank. If owned, throw dice and pay owner a total ten times the amount thrown.", action: "move_to_nearest", type: "utility" },
            { text: "Advance token to the nearest Station and pay owner twice the rental to which he/she is otherwise entitled. If Station is unowned, you may buy it from the Bank.", action: "move_to_nearest", type: "station", rentMultiplier: 2 },
            { text: "Bank pays you dividend of ৳500.", action: "add_money", amount: 500 },
            { text: "Get Out of Jail Free card.", action: "get_out_of_jail_free" },
            { text: "Go Back 3 Spaces.", action: "move_relative", steps: -3 },
            { text: "Go to Jail. Go directly to Jail, do not pass Go, do not collect ৳2000.", action: "go_to_jail" },
            { text: "Make general repairs on all your property. For each house pay ৳250, for each hotel ৳1000.", action: "repairs", houseCost: 250, hotelCost: 1000 }, // Simplified for now
            { text: "Pay poor tax of ৳150.", action: "remove_money", amount: 150 },
            { text: "Take a trip to কমলাপুর Station. If you pass Go, collect ৳2000.", action: "move_to", spaceIndex: 5, collectGo: true },
            { text: "Advance to জাফলং.", action: "move_to", spaceIndex: 39 },
            { text: "You have been elected Chairman of the Board. Pay each player ৳500.", action: "pay_players", amount: 500 },
            { text: "Your building loan matures. Collect ৳1500.", action: "add_money", amount: 1500 },
        ];
        // --- Community Chest Cards Definition (Example) ---
        const communityChestCards = [
            { text: "Advance to Go (Collect ৳2000).", action: "move_to", spaceIndex: 0, collectGo: true },
            { text: "Bank error in your favor. Collect ৳2000.", action: "add_money", amount: 2000 },
            { text: "Doctor’s fee. Pay ৳500.", action: "remove_money", amount: 500 },
            { text: "From sale of stock you get ৳500.", action: "add_money", amount: 500 },
            { text: "Get Out of Jail Free card.", action: "get_out_of_jail_free" },
            { text: "Go to Jail. Go directly to jail, do not pass Go, do not collect ৳2000.", action: "go_to_jail" },
            { text: "Holiday fund matures. Receive ৳1000.", action: "add_money", amount: 1000 },
            { text: "Income tax refund. Collect ৳200.", action: "add_money", amount: 200 },
            { text: "It is your birthday. Collect ৳100 from every player.", action: "collect_from_players", amount: 100 },
            { text: "Life insurance matures. Collect ৳1000.", action: "add_money", amount: 1000 },
            { text: "Pay hospital fees of ৳1000.", action: "remove_money", amount: 1000 },
            { text: "Pay school fees of ৳500.", action: "remove_money", amount: 500 },
            { text: "Receive ৳250 consultancy fee.", action: "add_money", amount: 250 },
            { text: "You are assessed for street repairs. ৳400 per house, ৳1150 per hotel.", action: "repairs", houseCost: 400, hotelCost: 1150 }, // Simplified
            { text: "You have won second prize in a beauty contest. Collect ৳100.", action: "add_money", amount: 100 },
            { text: "You inherit ৳1000.", action: "add_money", amount: 1000 },
        ];

        // --- Game State ---
        let players = [];
        let currentPlayerIndex = 0;
        let gameStarted = false;
        let dice1Value = 0;
        let dice2Value = 0;
        let doublesCount = 0;
        let shuffledChanceCards = [];
        let shuffledCommunityChestCards = [];
        let chanceCardIndex = 0;
        let communityChestCardIndex = 0;
        let turnActionsCompleted = false; // Flag to track if main action (buy/pay/card) is done

        // --- DOM Elements (Declare globally, assign in DOMContentLoaded) ---
        let boardElement, centerAreaElement, setupModal, startGameBtn, numPlayersSelect,
            playerNamesSetupDiv, playerInfoPanelsDiv, logScreen, dice1Element, dice2Element,
            rollDiceBtn, endTurnBtn, turnIndicator, notificationModal, notificationMessage,
            notificationButtons, actionButtonsDiv;

        // --- Utility Functions ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        function logMessage(message) {
            if (!logScreen) return; // Avoid error if logScreen not ready
            const p = document.createElement('p');
            p.textContent = message;
            logScreen.appendChild(p);
            logScreen.scrollTop = logScreen.scrollHeight; // Auto-scroll to bottom
        }

        function formatMoney(amount) {
             if (typeof amount !== 'number' || isNaN(amount)) {
                 console.warn("Invalid amount passed to formatMoney:", amount);
                 return '৳NaN';
             }
            return `৳${amount.toLocaleString('en-IN')}`;
        }

        // --- Dice Functions ---
        function rollDice() {
            dice1Value = Math.floor(Math.random() * 6) + 1;
            dice2Value = Math.floor(Math.random() * 6) + 1;
            if (dice1Element && dice2Element) { // Check if elements exist
                dice1Element.dataset.value = dice1Value;
                dice2Element.dataset.value = dice2Value;
            }
            return { roll1: dice1Value, roll2: dice2Value, total: dice1Value + dice2Value, isDouble: dice1Value === dice2Value };
        }

        // --- Player Functions ---
        function createPlayer(id, name) {
            return {
                id: id,
                name: name,
                money: STARTING_MONEY,
                position: 0,
                properties: [],
                stationsOwned: 0,
                utilitiesOwned: 0,
                inJail: false,
                jailTurns: 0,
                getOutOfJailFreeCards: 0,
                color: PLAYER_COLORS[id % PLAYER_COLORS.length], // Use modulo for safety
                token: PLAYER_TOKENS[id % PLAYER_TOKENS.length], // Use modulo for safety
                bankrupt: false
            };
        }

        function updatePlayerInfoPanel(player) {
            if (!playerInfoPanelsDiv) return; // Check if parent exists
            const panel = document.getElementById(`player-info-${player.id}`);
            if (!panel) return;

            const moneyEl = panel.querySelector('.player-money');
            const propsDiv = panel.querySelector('.player-properties');
            const statusDiv = panel.querySelector('.player-status');

            if (moneyEl) moneyEl.textContent = `Money: ${formatMoney(player.money)}`;
            if (statusDiv) {
                 let statusText = '';
                 if (player.inJail) statusText += ' (In Jail)';
                 if (player.getOutOfJailFreeCards > 0) statusText += ` (${player.getOutOfJailFreeCards}x Get Out of Jail Free)`;
                 statusDiv.textContent = statusText;
            }

            if (propsDiv) {
                propsDiv.innerHTML = 'Properties: '; // Clear previous
                player.properties.sort((a, b) => a - b);
                player.properties.forEach(propIndex => {
                    const space = boardSpaces[propIndex];
                    if (!space) return;
                    const propSpan = document.createElement('span');
                    propSpan.textContent = space.name;
                    const bgColorClass = space.color ? space.color.replace('bg-', 'bg-opacity-20') : 'bg-gray-200';
                    const borderColorClass = space.color ? space.color.replace('bg-', 'border-') : 'border-gray-400';
                    propSpan.className = `inline-block p-1 m-1 rounded text-xs border ${bgColorClass} ${borderColorClass}`;
                    propSpan.title = `Rent: ${formatMoney(space.rent || 0)}`;
                    propsDiv.appendChild(propSpan);
                });
            }

            // Highlight active player
            if (player.id === currentPlayerIndex && gameStarted) {
                panel.classList.add('active-player', 'border-blue-500', 'border-2');
                panel.classList.remove('border-gray-300');
            } else {
                panel.classList.remove('active-player', 'border-blue-500', 'border-2');
                panel.classList.add('border-gray-300');
            }
        }

        function movePlayer(player, steps) {
            const oldPosition = player.position;
             if (typeof steps !== 'number' || isNaN(steps)) {
                 console.error("Invalid steps for movePlayer:", steps);
                 checkTurnEnd(); // End turn if move is invalid
                 return;
             }
            player.position = (player.position + steps) % boardSpaces.length;
            const newPosition = player.position;

            const oldSpaceName = boardSpaces[oldPosition]?.name ?? `Space ${oldPosition}`;
            const newSpaceName = boardSpaces[newPosition]?.name ?? `Space ${newPosition}`;
            logMessage(`${player.name} rolled ${dice1Value} + ${dice2Value} = ${steps}. Moves from ${oldSpaceName} to ${newSpaceName}.`);

            // Check for passing Go
            if (newPosition < oldPosition && !player.inJail) {
                 const intendedDestinationIndex = (oldPosition + steps);
                 const intendedSpace = boardSpaces[intendedDestinationIndex];
                 const landedOnGoToJail = intendedSpace?.type === 'go-to-jail';
                 if (!landedOnGoToJail) {
                     player.money += GO_SALARY;
                     logMessage(`${player.name} passed Go and collected ${formatMoney(GO_SALARY)}.`);
                     updatePlayerInfoPanel(player);
                 }
            }

            updatePlayerMarkerPosition(player);
            setTimeout(() => handleSpaceAction(player, newPosition), 600);
        }

        function sendPlayerToJail(player) {
            logMessage(`${player.name} is going to Jail!`);
            const jailSpaceIndex = boardSpaces.findIndex(space => space.type === 'jail');
             if (jailSpaceIndex === -1) {
                 console.error("Jail space not found on board!");
                 checkTurnEnd(); // End turn if error
                 return;
             }
            player.position = jailSpaceIndex;
            player.inJail = true;
            player.jailTurns = 0;
            doublesCount = 0;
            updatePlayerMarkerPosition(player);
            updatePlayerInfoPanel(player);

            if (rollDiceBtn) rollDiceBtn.disabled = true;
            if (endTurnBtn) endTurnBtn.classList.add('hidden');
            setTimeout(endCurrentTurn, 600);
        }

         function getPlayerById(id) {
            return players.find(p => p.id === id);
         }

        // --- Board Drawing ---
        function drawBoard() {
            // Ensure elements are ready before drawing
            if (!boardElement || !centerAreaElement) {
                console.error("Board or Center Area element not found for drawing.");
                return;
            }
            boardElement.innerHTML = ''; // Clear previous board spaces, keep center area container
            boardElement.appendChild(centerAreaElement); // Re-add center area

            boardSpaces.forEach((space, index) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${index}`;
                spaceDiv.classList.add('space');

                // --- Grid Area Assignment (same as before) ---
                if (index === 0 || index === 10 || index === 20 || index === 30) {
                    spaceDiv.classList.add('corner');
                } else if (index > 0 && index < 10) { // Bottom Row
                    spaceDiv.classList.add('bottom-row');
                    spaceDiv.style.gridColumn = `${11 - index} / span 1`;
                } else if (index > 10 && index < 20) { // Left Column
                    spaceDiv.classList.add('left-col');
                     spaceDiv.style.gridRow = `${11 - (index - 10)} / span 1`;
                } else if (index > 20 && index < 30) { // Top Row
                    spaceDiv.classList.add('top-row');
                     spaceDiv.style.gridColumn = `${index - 20 + 1} / span 1`;
                } else if (index > 30 && index < 40) { // Right Column
                    spaceDiv.classList.add('right-col');
                     spaceDiv.style.gridRow = `${index - 30 + 1} / span 1`;
                }

                 // --- Content Creation ---
                 const nameDiv = document.createElement('div');
                 nameDiv.classList.add('space-name');
                 let icon = '';
                 let nameContent = space.name;
                 let priceDiv = null; // Initialize priceDiv

                 // Add color bar for properties first
                 if (space.type === 'property' && space.color) {
                     const colorDiv = document.createElement('div');
                     colorDiv.classList.add('property-color', space.color);
                     spaceDiv.appendChild(colorDiv); // Add color bar at the top
                 }

                 // Determine content and create price div if needed
                 switch (space.type) {
                     case 'property':
                     case 'station':
                     case 'utility':
                         if (space.price) {
                             priceDiv = document.createElement('div');
                             priceDiv.classList.add('space-price');
                             priceDiv.textContent = formatMoney(space.price);
                         }
                         if (space.type === 'station') icon = '🚂';
                         if (space.type === 'utility') icon = '💡';
                         break;
                     case 'tax':
                         icon = '💸';
                         nameContent += `<br>(${formatMoney(space.amount)})`;
                         break;
                     case 'chance':
                         nameContent = 'চান্স';
                         icon = '❓';
                         nameDiv.classList.add('text-blue-600', 'font-bold');
                         break;
                     case 'community-chest':
                         nameContent = 'কমিউনিটি<br>চেস্ট';
                         icon = '🎁';
                         nameDiv.classList.add('text-orange-500', 'font-bold');
                         break;
                     case 'go':
                         nameContent = 'শুরু <br> Collect <br>' + formatMoney(GO_SALARY);
                         icon = '🏁';
                         nameDiv.classList.add('text-red-600', 'font-bold');
                         break;
                     case 'jail':
                         nameContent = 'জেল / <br> শুধু পরিদর্শন';
                         icon = '👮';
                         break;
                     case 'free-parking':
                         nameContent = 'ফ্রি <br> পার্কিং';
                         icon = '🅿️';
                         break;
                     case 'go-to-jail':
                         nameContent = 'জেলে <br> যাও';
                         icon = '🚓';
                         break;
                 }

                 // Set name and icon content
                 nameDiv.innerHTML = nameContent + (icon ? `<br><span class="text-xl">${icon}</span>` : '');

                 // --- Append Elements in Order ---
                 spaceDiv.appendChild(nameDiv); // Add name div (after color bar if property)
                 if (priceDiv) {
                     spaceDiv.appendChild(priceDiv); // Add price div at the bottom if it exists
                 }

                 boardElement.appendChild(spaceDiv); // Add the completed space to the board
            });
        }

        function drawPlayerMarkers() {
             if (!boardElement) return;
             boardElement.querySelectorAll('.player-marker').forEach(marker => marker.remove());
            players.forEach(player => {
                 if (player.bankrupt) return;
                const marker = document.createElement('div');
                marker.id = `player-marker-${player.id}`;
                marker.classList.add('player-marker');
                marker.style.backgroundColor = player.color;
                marker.textContent = player.token;
                boardElement.appendChild(marker);
                updatePlayerMarkerPosition(player);
            });
        }

        function updatePlayerMarkerPosition(player) {
            if (!boardElement) return;
            const marker = document.getElementById(`player-marker-${player.id}`);
            const spaceElement = document.getElementById(`space-${player.position}`);
            if (!marker || !spaceElement) return;

            const boardRect = boardElement.getBoundingClientRect();
            const spaceRect = spaceElement.getBoundingClientRect();

            let targetLeft = spaceRect.left - boardRect.left + spaceRect.width / 2 - marker.offsetWidth / 2;
            let targetTop = spaceRect.top - boardRect.top + spaceRect.height / 2 - marker.offsetHeight / 2;

            const offsetMagnitude = 6;
            const angle = (player.id / players.length) * 2 * Math.PI;
            targetLeft += Math.cos(angle) * offsetMagnitude;
            targetTop += Math.sin(angle) * offsetMagnitude;

            marker.style.left = `${targetLeft}px`;
            marker.style.top = `${targetTop}px`;
        }

        function updatePropertyOwnershipVisual(spaceIndex, playerId) {
             const spaceElement = document.getElementById(`space-${spaceIndex}`);
             if (!spaceElement) return;

             const existingMarker = spaceElement.querySelector('.ownership-marker');
             if (existingMarker) existingMarker.remove();

             if (playerId !== null && playerId !== undefined) {
                 const player = getPlayerById(playerId);
                 if (!player || player.bankrupt) return;

                 const marker = document.createElement('div');
                 marker.classList.add('ownership-marker');
                 marker.style.backgroundColor = player.color;
                 marker.title = `Owned by ${player.name}`;
                 // Prepend marker so it's behind text/icons if z-index isn't enough
                 spaceElement.prepend(marker);
             }
        }


        // --- Game Logic ---
        function setupGame() {
            // Ensure setup elements exist
             if (!numPlayersSelect || !playerNamesSetupDiv || !setupModal || !logScreen || !rollDiceBtn || !endTurnBtn) {
                 console.error("Setup failed: One or more required DOM elements not found.");
                 alert("Error initializing game UI. Please refresh."); // User feedback
                 return;
             }

            const numPlayers = parseInt(numPlayersSelect.value);
            players = [];

             boardSpaces.forEach(space => { delete space.owner; });

            for (let i = 0; i < numPlayers; i++) {
                const nameInput = document.getElementById(`player-name-${i}`);
                // Check if nameInput exists before accessing value
                const playerName = nameInput ? (nameInput.value.trim() || `Player ${i + 1}`) : `Player ${i + 1}`;
                players.push(createPlayer(i, playerName));
            }

            currentPlayerIndex = 0;
            gameStarted = true;
            doublesCount = 0;
            chanceCardIndex = 0;
            communityChestCardIndex = 0;
            turnActionsCompleted = false;

            shuffledChanceCards = [...chanceCards];
            shuffledCommunityChestCards = [...communityChestCards];
            shuffleArray(shuffledChanceCards);
            shuffleArray(shuffledCommunityChestCards);

            logScreen.innerHTML = '';
            logMessage(`Game started with ${numPlayers} players.`);
            players.forEach(p => logMessage(`${p.name} (${p.token}) joins the game with ${formatMoney(p.money)}.`));

            drawBoard(); // Draw board content
            drawPlayerMarkers(); // Draw player pieces
            setupPlayerInfoPanels(); // Create panels
            updateAllPlayerPanels(); // Update panel content

            setupModal.classList.add('hidden');
            rollDiceBtn.disabled = false;
            endTurnBtn.classList.add('hidden');
            updateTurnIndicator();
        }

        function setupPlayerInfoPanels() {
            if (!playerInfoPanelsDiv) return;
            playerInfoPanelsDiv.innerHTML = '';
            players.forEach(player => {
                const panel = document.createElement('div');
                panel.id = `player-info-${player.id}`;
                panel.classList.add('player-info', 'bg-white', 'p-4', 'rounded-lg', 'shadow', 'mb-4', 'border', 'border-gray-300');
                panel.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                             <span class="inline-block w-5 h-5 rounded-full border border-gray-400" style="background-color: ${player.color};"></span>
                             <span class="font-bold player-name">${player.name} ${player.token}</span>
                             <span class="text-sm text-gray-600 player-status"></span>
                        </div>
                        <span class="font-semibold player-money">${formatMoney(player.money)}</span>
                    </div>
                    <div class="text-sm player-properties">Properties: None</div>
                `;
                playerInfoPanelsDiv.appendChild(panel);
            });
        }

         function updateAllPlayerPanels() {
             players.forEach(p => {
                 if (!p.bankrupt) {
                     updatePlayerInfoPanel(p);
                 } else {
                     const panel = document.getElementById(`player-info-${p.id}`);
                     if (panel) {
                         panel.classList.add('opacity-50');
                         const statusEl = panel.querySelector('.player-status');
                         if(statusEl) statusEl.textContent = ' (Bankrupt)';
                     }
                 }
             });
         }

        function updateTurnIndicator() {
             if (!turnIndicator) return;
             if (!players[currentPlayerIndex]) {
                 console.error("Current player index invalid:", currentPlayerIndex);
                 turnIndicator.textContent = "Game Over?";
                 return;
             }
            const currentPlayer = players[currentPlayerIndex];
            turnIndicator.textContent = `${currentPlayer.name}'s Turn`;
            updateAllPlayerPanels();
        }

        function handleRollDiceClick() {
            const currentPlayer = players[currentPlayerIndex];
            // Ensure button exists and is clickable
            if (!rollDiceBtn || rollDiceBtn.disabled || !currentPlayer || currentPlayer.bankrupt) return;

             if (currentPlayer.inJail) {
                 rollDiceBtn.disabled = true;
                 handleJailTurn(currentPlayer);
                 return;
             }

            rollDiceBtn.disabled = true;
            turnActionsCompleted = false;
            const { roll1, roll2, total, isDouble } = rollDice();

            if (isDouble) {
                doublesCount++;
                logMessage(`${currentPlayer.name} rolled doubles (${roll1})!`);
                if (doublesCount === 3) {
                    logMessage(`Rolled 3 doubles in a row! ${currentPlayer.name} goes to Jail!`);
                    sendPlayerToJail(currentPlayer);
                    return;
                }
            } else {
                doublesCount = 0;
            }

            movePlayer(currentPlayer, total);

            // Button state is handled by checkTurnEnd after move/action
        }

        function handleJailTurn(player) {
             player.jailTurns++;
             logMessage(`${player.name} is in Jail (Turn ${player.jailTurns}).`);

             let options = [];
             if (player.money >= JAIL_FINE) options.push({ text: `Pay ${formatMoney(JAIL_FINE)}`, action: 'pay_jail_fine' });
             if (player.getOutOfJailFreeCards > 0) options.push({ text: "Use 'Get Out of Jail Free' Card", action: 'use_jail_card' });
             options.push({ text: "Attempt to Roll Doubles", action: 'roll_for_jail' });

             if (player.jailTurns < 3) {
                options.push({ text: "End Turn (Stay in Jail)", action: 'stay_in_jail' });
             } else {
                 logMessage("This is the 3rd turn in jail. Must pay or use card if possible, otherwise attempt roll.");
                 if (player.money < JAIL_FINE && player.getOutOfJailFreeCards === 0) {
                     options = [{ text: "Attempt to Roll Doubles (Last Chance)", action: 'roll_for_jail' }];
                 } else {
                     options = options.filter(opt => opt.action !== 'roll_for_jail');
                 }
             }

             showNotification(
                 `${player.name}, you are in Jail (Turn ${player.jailTurns}). What do you want to do?`,
                 options.map(opt => createButton(opt.text, () => handleJailChoice(player, opt.action)))
             );
        }

        function handleJailChoice(player, choice) {
             hideNotification();
             switch (choice) {
                 case 'pay_jail_fine':
                     if (player.money >= JAIL_FINE) {
                         player.money -= JAIL_FINE;
                         player.inJail = false;
                         player.jailTurns = 0;
                         logMessage(`${player.name} paid ${formatMoney(JAIL_FINE)} to get out of Jail.`);
                         updatePlayerInfoPanel(player);
                         if(rollDiceBtn) rollDiceBtn.disabled = false; // Allow normal roll
                         turnActionsCompleted = true;
                         checkTurnEnd();
                     } else {
                         logMessage("Not enough money to pay the fine.");
                         handleJailTurn(player); // Re-prompt
                     }
                     break;
                 case 'use_jail_card':
                     if (player.getOutOfJailFreeCards > 0) {
                         player.getOutOfJailFreeCards--;
                         player.inJail = false;
                         player.jailTurns = 0;
                         logMessage(`${player.name} used a 'Get Out of Jail Free' card.`);
                         updatePlayerInfoPanel(player);
                         if(rollDiceBtn) rollDiceBtn.disabled = false; // Allow normal roll
                         turnActionsCompleted = true;
                         checkTurnEnd();
                     } else {
                         logMessage("No 'Get Out of Jail Free' card available.");
                         handleJailTurn(player); // Re-prompt
                     }
                     break;
                 case 'roll_for_jail':
                     const { roll1, roll2, total, isDouble } = rollDice();
                     logMessage(`${player.name} attempts to roll doubles... Rolled ${roll1} and ${roll2}.`);
                     if (isDouble) {
                         logMessage(`Success! ${player.name} is out of Jail.`);
                         player.inJail = false;
                         player.jailTurns = 0;
                         doublesCount = 0;
                         updatePlayerInfoPanel(player);
                         turnActionsCompleted = false;
                         movePlayer(player, total); // Move based on the roll
                     } else {
                         logMessage(`Failed to roll doubles.`);
                         if (player.jailTurns >= 3) {
                             logMessage(`Must pay ${formatMoney(JAIL_FINE)} now.`);
                             if (player.money >= JAIL_FINE) {
                                 player.money -= JAIL_FINE;
                                 player.inJail = false;
                                 player.jailTurns = 0;
                                 updatePlayerInfoPanel(player);
                                 logMessage(`${player.name} paid the fine after failing roll on 3rd turn.`);
                                 turnActionsCompleted = false;
                                 movePlayer(player, total); // Move based on the failed roll
                             } else {
                                 logMessage(`${player.name} cannot afford the fine after failing roll! (Bankruptcy check needed)`);
                                 endCurrentTurn();
                             }
                         } else {
                             endCurrentTurn(); // Failed roll, turn ends
                         }
                     }
                     break;
                 case 'stay_in_jail':
                     logMessage(`${player.name} decides to stay in Jail this turn.`);
                     endCurrentTurn();
                     break;
             }
        }


        function handleSpaceAction(player, spaceIndex) {
             if (spaceIndex < 0 || spaceIndex >= boardSpaces.length) {
                 console.error(`Invalid spaceIndex: ${spaceIndex}`);
                 checkTurnEnd(); return;
             }
            const space = boardSpaces[spaceIndex];
             if (!space) {
                 console.error(`No space definition for index: ${spaceIndex}`);
                 checkTurnEnd(); return;
             }
            logMessage(`${player.name} landed on ${space.name}.`);
            turnActionsCompleted = false;

            switch (space.type) {
                case 'property': case 'station': case 'utility':
                    handlePropertyLanding(player, spaceIndex); break;
                case 'go':
                    logMessage("Landed on Go."); turnActionsCompleted = true; checkTurnEnd(); break;
                case 'community-chest': drawCard('community-chest', player); break;
                case 'chance': drawCard('chance', player); break;
                case 'tax': payTax(player, space.amount, space.name); break;
                case 'jail':
                    logMessage(`${player.name} is just visiting Jail.`); turnActionsCompleted = true; checkTurnEnd(); break;
                case 'free-parking':
                    logMessage(`Enjoy the free parking!`); turnActionsCompleted = true; checkTurnEnd(); break;
                case 'go-to-jail': sendPlayerToJail(player); break; // Turn end handled within
                default:
                     logMessage(`Unhandled space type: ${space.type}`); turnActionsCompleted = true; checkTurnEnd(); break;
            }
             updateAllPlayerPanels();
        }

         function handlePropertyLanding(player, spaceIndex) {
             const space = boardSpaces[spaceIndex];
             const ownerId = space.owner;

             if (ownerId === undefined || ownerId === null) { // Unowned
                 if (player.money >= space.price) {
                     showNotification(
                         `Property ${space.name} (${formatMoney(space.price)}) is unowned. Buy it?`,
                         [
                             createButton("Yes", () => buyProperty(player, spaceIndex)),
                             createButton("No (Auction - Skipped)", () => {
                                 logMessage(`${player.name} declined to buy ${space.name}.`);
                                 hideNotification(); turnActionsCompleted = true; checkTurnEnd();
                             })
                         ]
                     );
                 } else {
                     logMessage(`${player.name} cannot afford ${space.name}. (Auction skipped)`);
                     turnActionsCompleted = true; checkTurnEnd();
                 }
             } else if (ownerId === player.id) { // Own property
                 logMessage(`${player.name} landed on their own property: ${space.name}.`);
                 turnActionsCompleted = true; checkTurnEnd();
             } else { // Owned by someone else
                 const owner = getPlayerById(ownerId);
                 if (owner && !owner.bankrupt && !owner.inJail) {
                     let rentAmount = calculateRent(spaceIndex, owner, dice1Value + dice2Value);
                     logMessage(`${player.name} must pay ${formatMoney(rentAmount)} rent to ${owner.name} for ${space.name}.`);
                     if (player.money >= rentAmount) {
                          showNotification(
                             `Pay ${formatMoney(rentAmount)} rent to ${owner.name}?`,
                             [createButton("Pay Rent", () => {
                                 player.money -= rentAmount; owner.money += rentAmount;
                                 logMessage(`${player.name} paid ${formatMoney(rentAmount)} rent.`);
                                 hideNotification(); updatePlayerInfoPanel(player); updatePlayerInfoPanel(owner);
                                 turnActionsCompleted = true; checkTurnEnd();
                             })]
                         );
                     } else {
                         logMessage(`${player.name} cannot afford rent of ${formatMoney(rentAmount)}! (Bankruptcy check needed)`);
                         turnActionsCompleted = true; checkTurnEnd();
                     }
                 } else if (owner && owner.inJail) {
                    logMessage(`${owner.name} is in Jail and cannot collect rent for ${space.name}.`);
                    turnActionsCompleted = true; checkTurnEnd();
                 } else if (owner && owner.bankrupt) {
                     logMessage(`${owner.name} is bankrupt and cannot collect rent.`);
                     turnActionsCompleted = true; checkTurnEnd();
                 } else {
                     logMessage(`Rent not applicable for ${space.name}.`);
                     turnActionsCompleted = true; checkTurnEnd();
                 }
             }
         }

         function buyProperty(player, spaceIndex) {
             hideNotification();
             const space = boardSpaces[spaceIndex];
             if (player.money >= space.price && (space.owner === undefined || space.owner === null)) {
                 player.money -= space.price;
                 space.owner = player.id;
                 player.properties.push(spaceIndex);
                 if (space.type === 'station') player.stationsOwned++;
                 if (space.type === 'utility') player.utilitiesOwned++;
                 logMessage(`${player.name} bought ${space.name} for ${formatMoney(space.price)}.`);
                 updatePlayerInfoPanel(player);
                 updatePropertyOwnershipVisual(spaceIndex, player.id);
                 turnActionsCompleted = true;
             } else {
                 logMessage(`Error buying property.`);
                 turnActionsCompleted = true;
             }
             checkTurnEnd();
         }

         function calculateRent(spaceIndex, owner, diceRoll) {
             const space = boardSpaces[spaceIndex];
             if (!owner || !space) return 0;
             // Add checks for mortgage later
             switch (space.type) {
                 case 'property':
                     // TODO: Monopoly check, house/hotel check
                     return space.rent || 0;
                 case 'station':
                     const stationsOwned = owner.properties.filter(propIdx => boardSpaces[propIdx]?.type === 'station').length;
                     return (space.rent || 250) * Math.pow(2, Math.max(0, stationsOwned - 1));
                 case 'utility':
                     const utilitiesOwned = owner.properties.filter(propIdx => boardSpaces[propIdx]?.type === 'utility').length;
                     if (utilitiesOwned === 1) return 40 * diceRoll;
                     if (utilitiesOwned >= 2) return 100 * diceRoll;
                     return 0;
                 default: return 0;
             }
         }

         function payTax(player, amount, taxName) {
             logMessage(`${player.name} landed on ${taxName} and must pay ${formatMoney(amount)}.`);
              if (player.money >= amount) {
                  showNotification(
                      `Pay ${formatMoney(amount)} for ${taxName}?`,
                      [createButton("Pay Tax", () => {
                          player.money -= amount;
                          logMessage(`${player.name} paid ${formatMoney(amount)} tax.`);
                          hideNotification(); updatePlayerInfoPanel(player);
                          turnActionsCompleted = true; checkTurnEnd();
                      })]
                  );
              } else {
                  logMessage(`${player.name} cannot afford tax of ${formatMoney(amount)}! (Bankruptcy check needed)`);
                  turnActionsCompleted = true; checkTurnEnd();
              }
         }

         function drawCard(deckType, player) {
             let card, deck, indexRef, deckName;
             if (deckType === 'chance') {
                 deck = shuffledChanceCards; indexRef = { index: chanceCardIndex }; deckName = 'Chance';
             } else {
                 deck = shuffledCommunityChestCards; indexRef = { index: communityChestCardIndex }; deckName = 'Community Chest';
             }
              if (!deck || deck.length === 0) {
                 logMessage(`No cards left in ${deckName} deck!`); turnActionsCompleted = true; checkTurnEnd(); return;
              }
             card = deck[indexRef.index];
             indexRef.index = (indexRef.index + 1) % deck.length;
             if (deckType === 'chance') {
                 chanceCardIndex = indexRef.index; if (chanceCardIndex === 0) shuffleArray(deck);
             } else {
                 communityChestCardIndex = indexRef.index; if (communityChestCardIndex === 0) shuffleArray(deck);
             }
             logMessage(`${player.name} drew ${deckName}: "${card.text}"`);
             showNotification(`${deckName} Card: ${card.text}`, [createButton("OK", () => {
                 hideNotification(); executeCardAction(player, card);
             })]);
         }

         function executeCardAction(player, card) {
             turnActionsCompleted = true; // Assume true unless move happens
             switch (card.action) {
                 case 'add_money':
                     player.money += card.amount; logMessage(`${player.name} received ${formatMoney(card.amount)}.`); break;
                 case 'remove_money':
                     if (player.money >= card.amount) {
                         player.money -= card.amount; logMessage(`${player.name} paid ${formatMoney(card.amount)}.`);
                     } else { logMessage(`${player.name} cannot afford to pay ${formatMoney(card.amount)}! (Bankruptcy check needed)`); }
                     break;
                 case 'move_to':
                     const oldPos = player.position;
                     if (typeof card.spaceIndex !== 'number' || card.spaceIndex < 0 || card.spaceIndex >= boardSpaces.length) { console.error("Invalid spaceIndex in card:", card); break; }
                     player.position = card.spaceIndex;
                     if (card.collectGo && player.position < oldPos && oldPos !== player.position) {
                         player.money += GO_SALARY; logMessage(`${player.name} passed Go and collected ${formatMoney(GO_SALARY)}.`);
                     }
                     const newSpaceName = boardSpaces[player.position]?.name ?? `Space ${player.position}`;
                     logMessage(`${player.name} moved to ${newSpaceName}.`);
                     updatePlayerMarkerPosition(player); turnActionsCompleted = false;
                     setTimeout(() => handleSpaceAction(player, player.position), 100); return;
                 case 'move_relative':
                      const currentPos = player.position; const steps = card.steps || 0;
                      const targetPos = (currentPos + steps + boardSpaces.length) % boardSpaces.length;
                      player.position = targetPos;
                      const targetSpaceName = boardSpaces[player.position]?.name ?? `Space ${player.position}`;
                      logMessage(`${player.name} moved ${steps > 0 ? steps : -steps} spaces ${steps > 0 ? 'forward' : 'backward'} to ${targetSpaceName}.`);
                      updatePlayerMarkerPosition(player); turnActionsCompleted = false;
                      setTimeout(() => handleSpaceAction(player, player.position), 100); return;
                 case 'go_to_jail': sendPlayerToJail(player); return;
                 case 'get_out_of_jail_free':
                     player.getOutOfJailFreeCards++; logMessage(`${player.name} received a 'Get Out of Jail Free' card.`); break;
                 case 'pay_players':
                     let totalPaid = 0; let canAffordAll = true;
                     const numOtherPlayers = players.filter(p => p.id !== player.id && !p.bankrupt).length;
                     if (player.money < card.amount * numOtherPlayers) {
                         logMessage(`${player.name} cannot afford to pay everyone ${formatMoney(card.amount)}! (Bankruptcy check needed)`); canAffordAll = false;
                     }
                     if (canAffordAll) {
                         players.forEach(otherPlayer => {
                             if (otherPlayer.id !== player.id && !otherPlayer.bankrupt) {
                                 player.money -= card.amount; otherPlayer.money += card.amount; totalPaid += card.amount; updatePlayerInfoPanel(otherPlayer);
                             }
                         });
                         logMessage(`${player.name} paid ${formatMoney(card.amount)} to each other player (Total: ${formatMoney(totalPaid)}).`);
                     }
                     break;
                 case 'collect_from_players':
                     let totalCollected = 0;
                     players.forEach(otherPlayer => {
                         if (otherPlayer.id !== player.id && !otherPlayer.bankrupt) {
                             let amountToCollect = card.amount;
                             if (otherPlayer.money >= amountToCollect) {
                                 otherPlayer.money -= amountToCollect; player.money += amountToCollect; totalCollected += amountToCollect; updatePlayerInfoPanel(otherPlayer);
                             } else {
                                  let amountCollected = otherPlayer.money; player.money += amountCollected; otherPlayer.money = 0; totalCollected += amountCollected; updatePlayerInfoPanel(otherPlayer);
                                  logMessage(`${otherPlayer.name} could only pay ${formatMoney(amountCollected)}. (Bankruptcy check needed)`);
                             }
                         }
                     });
                     logMessage(`${player.name} collected ${formatMoney(card.amount)} from each other player (Attempted Total: ${formatMoney(totalCollected)}).`);
                     break;
                 case 'move_to_nearest':
                      let nearestIndex = -1; let minDistance = boardSpaces.length; const currentPosition = player.position;
                      for (let i = 0; i < boardSpaces.length; i++) {
                          if (boardSpaces[i].type === card.type) {
                              let distance = (i - currentPosition + boardSpaces.length) % boardSpaces.length;
                              if (distance === 0) distance = boardSpaces.length; // If on the space, find next one
                              if (distance < minDistance) { minDistance = distance; nearestIndex = i; }
                          }
                      }
                      if (nearestIndex !== -1) {
                          logMessage(`Moving to nearest ${card.type}: ${boardSpaces[nearestIndex].name}`);
                          const oldPosNearest = player.position; player.position = nearestIndex;
                           if (player.position < oldPosNearest) { player.money += GO_SALARY; logMessage(`${player.name} passed Go and collected ${formatMoney(GO_SALARY)}.`); }
                          updatePlayerMarkerPosition(player); turnActionsCompleted = false;
                          const nearestSpace = boardSpaces[nearestIndex]; const ownerId = nearestSpace.owner;
                          if (ownerId !== undefined && ownerId !== null && ownerId !== player.id) {
                              const owner = getPlayerById(ownerId);
                              if (owner && !owner.bankrupt) { // Rent collection logic (simplified)
                                  let rentMultiplier = card.rentMultiplier || 1; let rentAmount;
                                  if (card.type === 'utility') {
                                       const { total } = rollDice(); logMessage(`${player.name} rolled ${total} for utility rent.`); rentAmount = total * 10; rentMultiplier = 1;
                                  } else { rentAmount = calculateRent(nearestIndex, owner, 0); }
                                  const finalRent = rentAmount * rentMultiplier;
                                  logMessage(`Owner found. ${player.name} must pay ${owner.name} ${formatMoney(finalRent)} (${rentMultiplier}x rent).`);
                                   setTimeout(() => { // Show payment prompt
                                       if (player.money >= finalRent) {
                                           showNotification(`Pay ${formatMoney(finalRent)} rent to ${owner.name}?`, [createButton("Pay Rent", () => {
                                                  player.money -= finalRent; owner.money += finalRent; logMessage(`${player.name} paid ${formatMoney(finalRent)} rent.`);
                                                  hideNotification(); updatePlayerInfoPanel(player); updatePlayerInfoPanel(owner); turnActionsCompleted = true; checkTurnEnd();
                                              })]);
                                       } else { logMessage(`${player.name} cannot afford rent!`); turnActionsCompleted = true; checkTurnEnd(); }
                                   }, 100);
                              } else { logMessage("Owner cannot collect rent."); turnActionsCompleted = true; checkTurnEnd(); }
                          } else { setTimeout(() => handleSpaceAction(player, nearestIndex), 100); } // Unowned or self-owned
                          return;
                      } else { logMessage(`No ${card.type} found on the board?`); }
                      break;
                 case 'repairs': logMessage(`Card action "${card.action}" not fully implemented.`); break;
                 default: logMessage(`Unknown card action: ${card.action}`);
             }
             updatePlayerInfoPanel(player);
             if (turnActionsCompleted) checkTurnEnd();
         }

        function checkTurnEnd() {
             const currentPlayer = players[currentPlayerIndex];
             // Ensure elements and player exist before proceeding
             if (!rollDiceBtn || !endTurnBtn || !currentPlayer || currentPlayer.bankrupt || currentPlayer.inJail) {
                 return;
             }

             if (doublesCount > 0 && doublesCount < 3) {
                 rollDiceBtn.disabled = false;
                 endTurnBtn.classList.add('hidden');
             } else if (turnActionsCompleted) {
                 rollDiceBtn.disabled = true;
                 endTurnBtn.classList.remove('hidden');
             } else { // Action pending
                 rollDiceBtn.disabled = true;
                 endTurnBtn.classList.add('hidden');
             }
        }


        function endCurrentTurn() {
            const currentPlayer = players[currentPlayerIndex];
            // Ensure elements and player exist
            if (!endTurnBtn || !rollDiceBtn || !currentPlayer) {
                 console.error("Cannot end turn: Missing elements or invalid player.");
                 return;
             }
             if (endTurnBtn.disabled) return; // Prevent double clicks
             endTurnBtn.disabled = true;

            logMessage(`${currentPlayer.name}'s turn ends.`);
            doublesCount = 0;
            turnActionsCompleted = false;

            const activePlayers = players.filter(p => !p.bankrupt);
             if (activePlayers.length <= 1) {
                 const winner = activePlayers[0];
                 logMessage(`--- GAME OVER ---`);
                 if (winner) {
                     logMessage(`${winner.name} is the winner!`);
                     showNotification(`${winner.name} wins the game!`, [createButton("New Game?", () => {
                         hideNotification(); setupModal.classList.remove('hidden'); gameStarted = false;
                         playerInfoPanelsDiv.innerHTML = '';
                         boardElement.querySelectorAll('.player-marker').forEach(m => m.remove());
                         boardElement.querySelectorAll('.ownership-marker').forEach(m => m.remove());
                         logScreen.innerHTML = '<p>Game Over. Set up a new game.</p>';
                         if (numPlayersSelect) numPlayersSelect.dispatchEvent(new Event('change'));
                     })]);
                 } else {
                      logMessage("No winner?"); showNotification("Game Over! No winner.", [createButton("OK", hideNotification)]);
                 }
                 rollDiceBtn.disabled = true; endTurnBtn.classList.add('hidden'); return;
             }

            let nextPlayerFound = false; let loopCheck = 0;
            do {
                currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
                if (!players[currentPlayerIndex].bankrupt) nextPlayerFound = true;
                loopCheck++;
            } while (!nextPlayerFound && loopCheck < players.length * 2);

             if (!nextPlayerFound) { console.error("Could not find next active player."); return; }

            rollDiceBtn.disabled = false;
            endTurnBtn.classList.add('hidden');
            endTurnBtn.disabled = false;
            if(actionButtonsDiv) actionButtonsDiv.querySelectorAll('.dynamic-action-btn').forEach(btn => btn.remove());

            updateTurnIndicator();
            logMessage(`--- ${players[currentPlayerIndex].name}'s turn ---`);
             if (players[currentPlayerIndex].inJail) {
                 logMessage(`${players[currentPlayerIndex].name} starts turn in Jail.`);
             }
        }

        // --- Notification Modal ---
        function showNotification(message, buttons = [createButton("OK", hideNotification)]) {
            if (!notificationModal || !notificationMessage || !notificationButtons) return;
            notificationMessage.textContent = message;
            notificationButtons.innerHTML = '';
            buttons.forEach(button => notificationButtons.appendChild(button));
            notificationModal.classList.remove('hidden');
        }

        function hideNotification() {
            if(notificationModal) notificationModal.classList.add('hidden');
        }

        function createButton(text, onClickAction) {
            const button = document.createElement('button');
            button.textContent = text;
            button.className = "bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-150 ease-in-out dynamic-action-btn m-1";
            button.onclick = onClickAction;
            return button;
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Setup Modal Listeners
            if (numPlayersSelect) {
                numPlayersSelect.addEventListener('change', (e) => {
                    if (!playerNamesSetupDiv) return;
                    const count = parseInt(e.target.value);
                    playerNamesSetupDiv.innerHTML = ''; // Clear previous
                    for (let i = 0; i < count; i++) {
                        const div = document.createElement('div');
                        div.classList.add('mb-2', 'flex', 'items-center', 'justify-center');
                        div.innerHTML = `
                            <label class="inline-block w-24 text-right font-medium mr-2" for="player-name-${i}">Player ${i + 1}:</label>
                            <input type="text" id="player-name-${i}" placeholder="Enter Name" class="player-name-input border rounded p-1 w-32">
                            <span class="inline-block w-5 h-5 rounded-full ml-2 border border-gray-400" style="background-color: ${PLAYER_COLORS[i % PLAYER_COLORS.length]};"></span>
                            <span class="ml-1 text-lg">${PLAYER_TOKENS[i % PLAYER_TOKENS.length]}</span>
                        `;
                        playerNamesSetupDiv.appendChild(div);
                    }
                });
                // Trigger change once immediately to show initial fields
                 numPlayersSelect.dispatchEvent(new Event('change'));
            } else {
                console.error("numPlayersSelect element not found.");
            }

            if (startGameBtn) {
                startGameBtn.addEventListener('click', setupGame);
            } else {
                 console.error("startGameBtn element not found.");
            }

            // Game Action Listeners
            if (rollDiceBtn) {
                rollDiceBtn.addEventListener('click', handleRollDiceClick);
            } else {
                 console.error("rollDiceBtn element not found.");
            }

            if (endTurnBtn) {
                endTurnBtn.addEventListener('click', endCurrentTurn);
            } else {
                 console.error("endTurnBtn element not found.");
            }

            // Window Resize Listener
            window.addEventListener('resize', () => {
                if(gameStarted && players.length > 0) {
                    players.forEach(p => { if (!p.bankrupt) updatePlayerMarkerPosition(p); });
                }
            });
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            // Assign DOM elements after they are loaded
            boardElement = document.getElementById('game-board');
            centerAreaElement = boardElement?.querySelector('.center-area'); // Use optional chaining
            setupModal = document.getElementById('setup-modal');
            startGameBtn = document.getElementById('start-game-btn');
            numPlayersSelect = document.getElementById('num-players');
            playerNamesSetupDiv = document.getElementById('player-names-setup');
            playerInfoPanelsDiv = document.getElementById('player-info-panels');
            logScreen = document.getElementById('log-screen');
            dice1Element = document.getElementById('dice1');
            dice2Element = document.getElementById('dice2');
            rollDiceBtn = document.getElementById('roll-dice-btn');
            endTurnBtn = document.getElementById('end-turn-btn');
            turnIndicator = document.getElementById('turn-indicator');
            notificationModal = document.getElementById('notification-modal');
            notificationMessage = document.getElementById('notification-message');
            notificationButtons = document.getElementById('notification-buttons');
            actionButtonsDiv = document.getElementById('action-buttons');

            // Check if essential elements were found
            if (!boardElement || !centerAreaElement || !setupModal || !startGameBtn || !numPlayersSelect) {
                 console.error("Essential DOM elements missing. Game cannot initialize properly.");
                 alert("Failed to load game interface. Please refresh the page.");
                 return;
             }

            // Draw the initial board structure (without player markers yet)
            drawBoard();
            // Setup event listeners
            setupEventListeners();
        });

    </script>
</body>
</html>
